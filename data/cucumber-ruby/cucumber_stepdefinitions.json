{
  "^I run `cucumber{}`'$": {
    "Code": "do\nexecute_cucumber(args)\nend",
    "File": "features/lib/step_definitions/command_line_steps.rb"
  },
  "^I run `bundle exec ruby {}`'$": {
    "Code": "do\nexecute_ruby(filename)\nend",
    "File": "features/lib/step_definitions/command_line_steps.rb"
  },
  "^I run `(bundle exec )rake {word}`'$": {
    "Code": "do\nexecute_rake(task)\nend",
    "File": "features/lib/step_definitions/command_line_steps.rb"
  },
  "^I run the feature with the progress formatter'$": {
    "Code": "do\nexecute_cucumber(\"features/ --format progress\")\nend",
    "File": "features/lib/step_definitions/command_line_steps.rb"
  },
  "^the exit status should be {int}'$": {
    "Code": "do\nexpect(command_line).to(have_exited_with(exit_code))\nend",
    "File": "features/lib/step_definitions/command_line_steps.rb"
  },
  "^it should {status}'$": {
    "Code": "do\nexpect(command_line).to(have_exited_with(status))\nend",
    "File": "features/lib/step_definitions/command_line_steps.rb"
  },
  "^it should {status} with:'$": {
    "Code": "do\nexpect(command_line).to(have_exited_with(status))\nexpect(command_line.all_output).to(include_output(output))\nend",
    "File": "features/lib/step_definitions/command_line_steps.rb"
  },
  "^it should {status} with exactly:'$": {
    "Code": "do\nexpect(command_line).to(have_exited_with(status))\nexpect(command_line.all_output).to(be_similar_output_than(output))\nend",
    "File": "features/lib/step_definitions/command_line_steps.rb"
  },
  "^the output should contain:'$": {
    "Code": "do\nexpect(command_line.all_output).to(include_output(output))\nend",
    "File": "features/lib/step_definitions/command_line_steps.rb"
  },
  "^the output should contain {string}'$": {
    "Code": "do\nexpect(command_line.all_output).to(include_output(output))\nend",
    "File": "features/lib/step_definitions/command_line_steps.rb"
  },
  "^the output includes the message {string}'$": {
    "Code": "do\nexpect(command_line.all_output).to(include(message))\nend",
    "File": "features/lib/step_definitions/command_line_steps.rb"
  },
  "^the output should not contain'$": {
    "Code": "do\nexpect(command_line.all_output).not_to(include_output(output))\nend",
    "File": "features/lib/step_definitions/command_line_steps.rb"
  },
  "^the output should not contain {string}'$": {
    "Code": "do\nexpect(command_line.all_output).not_to(include_output(output))\nend",
    "File": "features/lib/step_definitions/command_line_steps.rb"
  },
  "^the stdout should contain exactly:'$": {
    "Code": "do\nexpect(command_line.stdout).to(be_similar_output_than(output))\nend",
    "File": "features/lib/step_definitions/command_line_steps.rb"
  },
  "^the stderr should contain$": {
    "Code": "do\nexpect(command_line.stderr).to(include_output(output))\nend",
    "File": "features/lib/step_definitions/command_line_steps.rb"
  },
  "^the stderr should not contain$": {
    "Code": "do\nexpect(command_line.stderr).not_to(include_output(output))\nend",
    "File": "features/lib/step_definitions/command_line_steps.rb"
  },
  "^the stderr should not contain anything'$": {
    "Code": "do\nexpect(command_line.stderr).to(be_empty)\nend",
    "File": "features/lib/step_definitions/command_line_steps.rb"
  },
  "^I should see the CLI help$": {
    "Code": "do\nexpect(command_line.stdout).to(include(\"Usage:\"))\nend",
    "File": "features/lib/step_definitions/cucumber_cli_steps.rb"
  },
  "^a directory without standard Cucumber project directory structure$": {
    "Code": "do\nFileUtils.cd(\".\") {\n  if File.directory?(\"features\")\n    FileUtils.rm_rf(\"features\")\n  end\n}\nend",
    "File": "features/lib/step_definitions/cucumber_steps.rb"
  },
  "^log only formatter is declared$": {
    "Code": "do\nwrite_file(\"features/support/log_only_formatter.rb\", [\"class LogOnlyFormatter\", \"  attr_reader :io\", \"\", \"  def initialize(config)\", \"    @io = config.out_stream\", \"  end\", \"\", \"  def attach(src, media_type, _filename)\", \"    @io.puts(src)\", \"  end\", \"end\"].join(\"\\n\"))\nend",
    "File": "features/lib/step_definitions/cucumber_steps.rb"
  },
  "^exactly these files should be loaded: {list}$": {
    "Code": "do\nexpect(command_line.stdout.scan(/^  \\* (.*\\.rb)$/).flatten).to(eq(files))\nend",
    "File": "features/lib/step_definitions/cucumber_steps.rb"
  },
  "^exactly these features should be run: {list}$": {
    "Code": "do\nexpect(command_line.stdout.scan(/^  \\* (.*\\.feature)$/).flatten).to(eq(files))\nend",
    "File": "features/lib/step_definitions/cucumber_steps.rb"
  },
  "^{string} should not be required$": {
    "Code": "do\nexpect(command_line.stdout).not_to(include(\"* #{file_name}\"))\nend",
    "File": "features/lib/step_definitions/cucumber_steps.rb"
  },
  "^{string} should be required$": {
    "Code": "do\nexpect(command_line.stdout).to(include(\"* #{file_name}\"))\nend",
    "File": "features/lib/step_definitions/cucumber_steps.rb"
  },
  "^it fails before running features with:$": {
    "Code": "do\nexpect(command_line.all_output).to(start_with_output(expected))\nexpect(command_line).to(have_failed)\nend",
    "File": "features/lib/step_definitions/cucumber_steps.rb"
  },
  "^the file {string} should contain:$": {
    "Code": "do\nexpect(File.read(path)).to(include(content))\nend",
    "File": "features/lib/step_definitions/cucumber_steps.rb"
  },
  "^I rerun the previous command with the same seed$": {
    "Code": "do\nprevious_seed = command_line.stdout.match(/with seed (\\d+)/).[](1)\nexecute_extra_cucumber(command_line.args.gsub(/random/, \"random:#{previous_seed}\"))\nend",
    "File": "features/lib/step_definitions/cucumber_steps.rb"
  },
  "^the output of both commands should be the same$": {
    "Code": "do\nexpect(command_line.stdout).to(be_similar_output_than(last_extra_command.stdout))\nend",
    "File": "features/lib/step_definitions/cucumber_steps.rb"
  },
  "^a directory named {string}$": {
    "Code": "do\nFileUtils.mkdir_p(path)\nend",
    "File": "features/lib/step_definitions/filesystem_steps.rb"
  },
  "^a file named {string} with:$": {
    "Code": "do\nwrite_file(path, content)\nend",
    "File": "features/lib/step_definitions/filesystem_steps.rb"
  },
  "^an empty file named {string}$": {
    "Code": "do\nwrite_file(path, \"\")\nend",
    "File": "features/lib/step_definitions/filesystem_steps.rb"
  },
  "^a file named {string} should exist$": {
    "Code": "do\nexpect(File.file?(path)).to(be(true))\nend",
    "File": "features/lib/step_definitions/filesystem_steps.rb"
  },
  "^it should fail with JSON:$": {
    "Code": "do\nexpect(command_line).to(have_failed)\nactual = normalise_json(JSON.parse(command_line.stdout))\nexpected = JSON.parse(json)\nexpect(actual).to(eq(expected))\nend",
    "File": "features/lib/step_definitions/json_steps.rb"
  },
  "^it should pass with JSON:$": {
    "Code": "do\nexpect(command_line).to(have_succeded)\nactual = normalise_json(JSON.parse(command_line.stdout))\nexpected = JSON.parse(json)\nexpect(actual).to(eq(expected))\nend",
    "File": "features/lib/step_definitions/json_steps.rb"
  },
  "^file {string} should contain JSON:$": {
    "Code": "do\nactual = normalise_json(JSON.parse(File.read(filename)))\nexpected = JSON.parse(json)\nexpect(actual).to(eq(expected))\nend",
    "File": "features/lib/step_definitions/json_steps.rb"
  },
  "^ messages types should be:$": {
    "Code": "do\nparsed_json = command_line.stdout.split(\"\\n\").map { |line,|\n  JSON.parse(line)\n}\nmessage_types = parsed_json.map(&:keys).flatten.compact\nexpect(expected_types.split(\"\\n\").map(&:strip)).to(contain_exactly(*message_types))\nend",
    "File": "features/lib/step_definitions/message_steps.rb"
  },
  "^ output should be valid NDJSON$": {
    "Code": "do\ncommand_line.stdout.split(\"\\n\").map { |line,|\n  expect {\n    JSON.parse(line)\n  }.not_to(raise_exception)\n}\nend",
    "File": "features/lib/step_definitions/message_steps.rb"
  },
  "^ the output should contain NDJSON with key {string}$": {
    "Code": "do\nexpect(command_line.stdout).to(match(/\"#{key}\":/))\nend",
    "File": "features/lib/step_definitions/message_steps.rb"
  },
  "^ the output should contain NDJSON with key {string} and value {string}$": {
    "Code": "do\nexpect(command_line.stdout).to(match(/\"#{key}\": ?\"#{value}\"/))\nend",
    "File": "features/lib/step_definitions/message_steps.rb"
  },
  "^the standard step definitions$": {
    "Code": "do\nwrite_file(\"features/step_definitions/steps.rb\", [step_definition(\"/^this step passes$/\", \"\"), step_definition(\"/^this step raises an error$/\", \"raise 'error'\"), step_definition(\"/^this step is pending$/\", \"pending\"), step_definition(\"/^this step fails$/\", \"fail\"), step_definition(\"/^this step is a table step$/\", \"|t|\")].join(\"\\n\"))\nend",
    "File": "features/lib/step_definitions/scenarios_and_steps.rb"
  },
  "^a scenario with a step that looks like this:$": {
    "Code": "do\ncreate_feature {\n  create_scenario {\n    string\n  }\n}\nend",
    "File": "features/lib/step_definitions/scenarios_and_steps.rb"
  },
  "^a scenario with a step that looks like this in japanese:$": {
    "Code": "do\ncreate_feature_ja {\n  create_scenario_ja {\n    string\n  }\n}\nend",
    "File": "features/lib/step_definitions/scenarios_and_steps.rb"
  },
  "^a scenario {string} that passes$": {
    "Code": "do\ncreate_feature(name) {\n  create_scenario(name) {\n    \"  Given it passes in #{name}\"\n  }\n}\nwrite_file(\"features/step_definitions/#{name}_steps.rb\", step_definition(\"/^it passes in #{name}$/\", \"expect(true).to be true\"))\nend",
    "File": "features/lib/step_definitions/scenarios_and_steps.rb"
  },
  "^a scenario {string} that fails$": {
    "Code": "do\ncreate_feature(name) {\n  create_scenario(name) {\n    \"  Given it fails in #{name}\"\n  }\n}\nwrite_file(\"features/step_definitions/#{name}_steps.rb\", step_definition(\"/^it fails in #{name}$/\", \"expect(false).to be true\"))\nend",
    "File": "features/lib/step_definitions/scenarios_and_steps.rb"
  },
  "^a scenario {string} that fails once, then passes$": {
    "Code": "do\nname = snake_case(full_name)\ncreate_feature(\"#{full_name} feature\") {\n  create_scenario(full_name) {\n    \"  Given it fails once, then passes in #{full_name}\"\n  }\n}\nwrite_file(\"features/step_definitions/#{name}_steps.rb\", step_definition(\"/^it fails once, then passes in #{full_name}$/\", [\"$#{name} += 1\", \"expect($#{name}).to be > 1\"]))\nwrite_file(\"features/support/#{name}_init.rb\", \"  $#{name} = 0\")\nend",
    "File": "features/lib/step_definitions/scenarios_and_steps.rb"
  },
  "^a scenario {string} that fails twice, then passes$": {
    "Code": "do\nname = snake_case(full_name)\ncreate_feature(\"#{full_name} feature\") {\n  create_scenario(full_name) {\n    \"  Given it fails twice, then passes in #{full_name}\"\n  }\n}\nwrite_file(\"features/step_definitions/#{name}_steps.rb\", step_definition(\"/^it fails twice, then passes in #{full_name}$/\", [\"$#{name} ||= 0\", \"$#{name} += 1\", \"expect($#{name}).to be > 2\"]))\nwrite_file(\"features/support/#{name}_init.rb\", \"  $#{name} = 0\")\nend",
    "File": "features/lib/step_definitions/scenarios_and_steps.rb"
  },
  "^a step definition that looks like this:$": {
    "Code": "do\nwrite_file(\"features/step_definitions/steps#{SecureRandom.uuid}.rb\", content)\nend",
    "File": "features/lib/step_definitions/scenarios_and_steps.rb"
  }
}
